diff --git a/components/sync_bookmarks/synced_bookmark_tracker.cc b/components/sync_bookmarks/synced_bookmark_tracker.cc
index 559ece6b2d651317b6871981ab9f024d0cb55455..d1931080f6cbcc81ed1dfc14d5bdb4235be32351 100644
--- a/components/sync_bookmarks/synced_bookmark_tracker.cc
+++ b/components/sync_bookmarks/synced_bookmark_tracker.cc
@@ -505,6 +505,18 @@ SyncedBookmarkTracker::InitEntitiesFromModelAndMetadata(
     sync_id_to_entities_map_[sync_id] = std::move(entity);
   }
 
+  VLOG(1) << "[BraveSync] " << __func__ << " sync_id_to_entities_map_:------------";
+  for (const auto &entry:sync_id_to_entities_map_) {
+    VLOG(1) << "[BraveSync] " << __func__ << " entry.first="<<entry.first;
+    VLOG(1) << "[BraveSync] " << __func__ << " entry.second->IsUnsynced()="<<entry.second;
+    if (entry.second){
+      VLOG(1) << "[BraveSync] " << __func__ << " entry.second->IsUnsynced()="<<entry.second->IsUnsynced();
+      VLOG(1) << "[BraveSync] " << __func__ << " entry.second->bookmark_node()="<<entry.second->bookmark_node();
+    }
+    VLOG(1) << "[BraveSync] " << __func__ << "---";
+  }
+  VLOG(1) << "[BraveSync] " << __func__ << "------------";
+
   // See if there are untracked entities in the BookmarkModel.
   std::vector<int> model_node_ids;
   ui::TreeNodeIterator<const bookmarks::BookmarkNode> iterator(
@@ -515,6 +527,7 @@ SyncedBookmarkTracker::InitEntitiesFromModelAndMetadata(
       continue;
     }
     if (bookmark_node_to_entities_map_.count(node) == 0) {
+      VLOG(1) << "[BraveSync] " << __func__ << " return CorruptionReason::UNTRACKED_BOOKMARK";
       return CorruptionReason::UNTRACKED_BOOKMARK;
     }
   }
@@ -525,6 +538,7 @@ SyncedBookmarkTracker::InitEntitiesFromModelAndMetadata(
           client_tag_mismatch_found, bookmark_without_client_tag_found));
 
   CheckAllNodesTracked(model);
+  VLOG(1) << "[BraveSync] " << __func__ << " return CorruptionReason::NO_CORRUPTION";
   return CorruptionReason::NO_CORRUPTION;
 }
 
@@ -599,6 +613,11 @@ void SyncedBookmarkTracker::UpdateUponCommitResponse(
     const std::string& new_id,
     int64_t acked_sequence_number,
     int64_t server_version) {
+  VLOG(1) << "[BraveSync] " << __func__ << " old_id=" << old_id;
+  VLOG(1) << "[BraveSync] " << __func__ << " new_id=" << new_id;
+  VLOG(1) << "[BraveSync] " << __func__ << " acked_sequence_number=" << acked_sequence_number;
+  VLOG(1) << "[BraveSync] " << __func__ << " server_version=" << server_version;
+
   // TODO(crbug.com/516866): Update specifics if we decide to keep it.
   Entity* entity = GetMutableEntityForSyncId(old_id);
   if (!entity) {
@@ -620,7 +639,10 @@ void SyncedBookmarkTracker::UpdateUponCommitResponse(
 void SyncedBookmarkTracker::UpdateSyncForLocalCreationIfNeeded(
     const std::string& old_id,
     const std::string& new_id) {
+  VLOG(1) << "[BraveSync] " << __func__ << " old_id=" << old_id;
+  VLOG(1) << "[BraveSync] " << __func__ << " new_id=" << new_id;
   if (old_id == new_id) {
+    VLOG(1) << "[BraveSync] " << __func__ << " early exit ids are equal";
     return;
   }
   // TODO(crbug.com/516866): The below CHECK is added to debug some crashes.
